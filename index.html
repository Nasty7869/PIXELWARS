<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mon PixelWar Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Styles CSS personnalisés pour la grille et les pixels */
        body {
            font-family: 'Inter', sans-serif; /* Utilisation de la police Inter */
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0; /* Supprime la marge par défaut du body */
            background-color: #e2e8f0; /* Un gris-bleu plus doux */
            min-height: 100vh;
            justify-content: center; /* Centre le contenu verticalement */
            padding: 0; /* Supprime le padding du body pour que la grille puisse prendre toute la place */
            box-sizing: border-box; /* Inclut le padding dans la taille totale */
            overflow: hidden; /* Empêche le défilement du body pour le zoom */
        }

        #pixel-grid {
            display: grid;
            border: 1px solid #cbd5e1; /* Bordure plus douce */
            background-color: white;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); /* Ombre plus prononcée */
            position: relative;
            border-radius: 0; /* Supprime les bords arrondis du tableau */
            overflow: hidden; /* Pour que les pixels ne dépassent pas les bords */
            flex-grow: 1; /* Permet à la grille de prendre l'espace disponible */
            cursor: grab; /* Curseur pour indiquer que la grille est déplaçable */
        }

        .pixel {
            background-color: #fff;
            border: 0.5px solid #f0f0f0; /* Bordure de pixel très légère */
            position: relative;
            cursor: pointer;
            border-radius: 2px; /* Bords légèrement arrondis pour les pixels */
            transition: background-color 0.1s ease-in-out; /* Transition douce pour la couleur */
        }

        .pixel .tooltip {
            visibility: hidden;
            width: auto;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            text-align: center;
            border-radius: 0.5rem;
            padding: 5px 8px;
            position: absolute;
            z-index: 1000;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            white-space: nowrap;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            pointer-events: none;
        }

        .pixel:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            max-width: 90%;
            width: 400px;
            text-align: center;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
        }

        .modal-overlay.show .modal-content {
            transform: translateY(0);
        }

        #message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #message-box.show {
            opacity: 1;
            visibility: visible;
        }
        #message-box.error {
            background-color: #f44336;
        }
        #message-box.info {
            background-color: #2196F3;
        }

        #archive-modal .modal-content {
            width: 500px;
        }

        #timer-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #1f2937;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 9999;
            font-size: 1rem;
            font-weight: 500;
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #timer-container.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        #controls-container {
            position: fixed;
            top: 20px; 
            right: 20px;
            z-index: 9990; 
            display: flex;
            flex-direction: column; /* Pour empiler les boutons verticalement */
            gap: 10px;
        }

        .control-button {
            padding: 10px 15px;
            background-color: #60a5fa; 
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.2s ease-in-out;
            text-align: center;
        }
        .control-button:hover {
            background-color: #3b82f6; 
        }
        .control-button:disabled {
            background-color: #9ca3af; /* Gris pour le bouton désactivé */
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center min-h-screen">
    <div id="pixel-grid"></div>

    <div id="controls-container">
        <button id="fill-grid-test-btn" class="control-button">Remplir (Test)</button>
        <button id="export-grid-html-btn" class="control-button">Exporter HTML (Manuel)</button>
    </div>

    <!-- Modale de sélection de couleur -->
    <div id="color-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Choisissez une couleur</h2>
            <div id="modal-palette" class="flex justify-center flex-wrap gap-2 mb-6">
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: red;" data-color="red"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: blue;" data-color="blue"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: green;" data-color="green"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: yellow;" data-color="yellow"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: black;" data-color="black"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: white;" data-color="white"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: orange;" data-color="orange"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: purple;" data-color="purple"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: pink;" data-color="pink"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: cyan;" data-color="cyan"></div>
                 <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: magenta;" data-color="magenta"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: lime;" data-color="lime"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: teal;" data-color="teal"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: brown;" data-color="brown"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: navy;" data-color="navy"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: silver;" data-color="silver"></div>
            </div>
            <button id="color-modal-cancel-btn" class="px-6 py-3 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">Annuler</button>
        </div>
    </div>

    <div id="username-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Quel est votre pseudo ?</h2>
            <input type="text" id="username-input" class="w-full p-3 border border-gray-300 rounded-lg mb-6 text-lg focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Entrez votre pseudo ici..." maxlength="20">
            <div class="flex justify-center space-x-4">
                <button id="modal-ok-btn" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">Envoyer</button>
                <button id="modal-cancel-btn" class="px-6 py-3 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">Annuler</button>
            </div>
        </div>
    </div>

    <div id="archive-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Grille Complète !</h2>
            <p class="text-gray-700 mb-6">La grille de pixels est entièrement remplie. Voulez-vous archiver son état actuel (données et visuel sur Drive) et commencer une nouvelle grille ?</p>
            <div class="flex justify-center space-x-4">
                <button id="archive-ok-btn" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">Archiver et Réinitialiser</button>
                <button id="archive-cancel-btn" class="px-6 py-3 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">Non, merci</button>
            </div>
        </div>
    </div>

    <div id="message-box"></div>

    <div id="timer-container" class="hidden">
        Prochain pixel dans : <span id="timer-countdown">00:00</span>
    </div>

    <script>
        const APPS_SCRIPT_API_URL = 'https://script.google.com/macros/s/AKfycbzJZK_U8D6nUuaihdz0MC7z8nVuH6NwJNr-cMptmKfRRSzlt1wk2ipOaixozqCucJ4i/exec'; 
        const gridSize = 50; 
        const RATE_LIMIT_MINUTES = 3; 

        const pixelGrid = document.getElementById('pixel-grid');
        let currentColor = 'red'; 

        const colorModal = document.getElementById('color-modal');
        const modalPalette = document.getElementById('modal-palette');
        const colorModalCancelBtn = document.getElementById('color-modal-cancel-btn');
        const usernameModal = document.getElementById('username-modal');
        const usernameInput = document.getElementById('username-input');
        const modalOkBtn = document.getElementById('modal-ok-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const archiveModal = document.getElementById('archive-modal');
        const archiveOkBtn = document.getElementById('archive-ok-btn');
        const archiveCancelBtn = document.getElementById('archive-cancel-btn');
        const messageBox = document.getElementById('message-box');
        const timerContainer = document.getElementById('timer-container');
        const timerCountdown = document.getElementById('timer-countdown');
        let cooldownInterval; 

        const fillGridTestBtn = document.getElementById('fill-grid-test-btn');
        const exportGridHtmlBtn = document.getElementById('export-grid-html-btn');


        let resolveColorModalPromise, resolveUsernameModalPromise, resolveArchiveModalPromise;
        let currentZoomLevel = 1.0, zoomStep = 0.1, minZoom = 1.0, maxZoom = 5.0;
        let isDragging = false, startX, startY, currentTranslateX = 0, currentTranslateY = 0;

        const targetRatioWidth = 16;
        const targetRatioHeight = 9;
        const totalGridHeightPixels = Math.round(gridSize * (targetRatioHeight / targetRatioWidth)); 
        const totalPixelsInGrid = gridSize * totalGridHeightPixels;

        function showMessage(message, type = 'success') {
            messageBox.textContent = message;
            messageBox.className = `message-box show ${type}`;
            setTimeout(() => messageBox.classList.remove('show'), 3000);
        }

        function startCooldownTimer(minutes) {
            clearInterval(cooldownInterval); 
            const endTime = new Date().getTime() + minutes * 60 * 1000;
            timerContainer.classList.remove('hidden'); 
            cooldownInterval = setInterval(() => {
                const now = new Date().getTime();
                const distance = endTime - now;
                if (distance < 0) {
                    clearInterval(cooldownInterval);
                    timerContainer.classList.add('hidden'); 
                    return;
                }
                const remainingMinutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const remainingSeconds = Math.floor((distance % (1000 * 60)) / 1000);
                timerCountdown.textContent = `${remainingMinutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        function setPixelGridSize() {
            const availableWidth = document.documentElement.clientWidth;
            const availableHeight = document.documentElement.clientHeight;
            let pixelSize = Math.min(availableWidth / gridSize, availableHeight / totalGridHeightPixels) * currentZoomLevel;
            
            pixelGrid.style.width = `${pixelSize * gridSize}px`;
            pixelGrid.style.height = `${pixelSize * totalGridHeightPixels}px`;
            pixelGrid.style.gridTemplateColumns = `repeat(${gridSize}, ${pixelSize}px)`;
            pixelGrid.style.gridTemplateRows = `repeat(${totalGridHeightPixels}, ${pixelSize}px)`;
        }

        function centerGrid() {
            if (!pixelGrid.style.width || !pixelGrid.style.height) setPixelGridSize();
            const gridRect = pixelGrid.getBoundingClientRect();
            currentTranslateX = (window.innerWidth - gridRect.width) / 2;
            currentTranslateY = (window.innerHeight - gridRect.height) / 2;
            pixelGrid.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px)`;
        }

        pixelGrid.addEventListener('wheel', (event) => {
            event.preventDefault();
            const oldZoomLevel = currentZoomLevel;
            const rect = pixelGrid.getBoundingClientRect();
            const mouseXRatio = (event.clientX - rect.left) / rect.width;
            const mouseYRatio = (event.clientY - rect.top) / rect.height;

            currentZoomLevel = event.deltaY < 0 ? Math.min(maxZoom, currentZoomLevel + zoomStep) : Math.max(minZoom, currentZoomLevel - zoomStep);

            if (oldZoomLevel !== currentZoomLevel) {
                const oldWidth = rect.width, oldHeight = rect.height;
                setPixelGridSize(); 
                const newWidth = pixelGrid.offsetWidth, newHeight = pixelGrid.offsetHeight;
                currentTranslateX -= (newWidth - oldWidth) * mouseXRatio;
                currentTranslateY -= (newHeight - oldHeight) * mouseYRatio;
                pixelGrid.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px)`;
            }
        });

        pixelGrid.addEventListener('mousedown', (event) => {
            if (event.button === 1) { 
                event.preventDefault();
                isDragging = true;
                startX = event.clientX - currentTranslateX;
                startY = event.clientY - currentTranslateY;
                pixelGrid.style.cursor = 'grabbing';
            }
        });

        window.addEventListener('mousemove', (event) => {
            if (!isDragging) return;
            event.preventDefault();
            currentTranslateX = event.clientX - startX;
            currentTranslateY = event.clientY - startY;
            pixelGrid.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px)`;
        });

        window.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                pixelGrid.style.cursor = 'grab';
            }
        });

        function showColorModal() {
            return new Promise(resolve => { resolveColorModalPromise = resolve; colorModal.classList.add('show'); });
        }
        function showUsernameModal() {
            return new Promise(resolve => { resolveUsernameModalPromise = resolve; usernameInput.value = ''; usernameModal.classList.add('show'); usernameInput.focus(); });
        }
        function showArchiveModal() {
            return new Promise(resolve => { resolveArchiveModalPromise = resolve; archiveModal.classList.add('show'); });
        }

        modalPalette.addEventListener('click', (event) => {
            if (event.target.classList.contains('color-box')) {
                colorModal.classList.remove('show');
                resolveColorModalPromise(event.target.dataset.color);
            }
        });
        colorModalCancelBtn.addEventListener('click', () => { colorModal.classList.remove('show'); resolveColorModalPromise(null); });
        modalOkBtn.addEventListener('click', () => {
            usernameModal.classList.remove('show');
            resolveUsernameModalPromise(usernameInput.value.trim() === '' ? 'Anonyme' : usernameInput.value.trim());
        });
        modalCancelBtn.addEventListener('click', () => { usernameModal.classList.remove('show'); resolveUsernameModalPromise(null); });
        usernameInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') modalOkBtn.click(); });
        archiveOkBtn.addEventListener('click', () => { archiveModal.classList.remove('show'); resolveArchiveModalPromise(true); });
        archiveCancelBtn.addEventListener('click', () => { archiveModal.classList.remove('show'); resolveArchiveModalPromise(false); });

        function updatePixelOnGrid(x, y, color, user) {
            const pixelElement = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (pixelElement) { 
                pixelElement.style.backgroundColor = color;
                pixelElement.dataset.color = color;
                pixelElement.dataset.user = user; // S'assurer que le dataset.user est mis à jour
                pixelElement.querySelector('.tooltip').textContent = user;
            }
        }
        
        function resetGridClientSide() {
            const pixels = pixelGrid.querySelectorAll('.pixel');
            pixels.forEach(p => {
                p.style.backgroundColor = '#fff'; 
                p.dataset.color = '#fff';
                p.dataset.user = 'Vide';
                p.querySelector('.tooltip').textContent = 'Vide';
            });
            showMessage('Nouvelle grille prête !', 'info');
        }

        async function addPixel(x, y, color, userName) {
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=addPixel&x=${x}&y=${y}&color=${encodeURIComponent(color)}&user=${encodeURIComponent(userName)}`;
                const response = await fetch(url); // GET request
                const result = await response.json();
                if (result.success) {
                    updatePixelOnGrid(result.pixel.x, result.pixel.y, result.pixel.color, result.pixel.user);
                    showMessage('Pixel placé avec succès !', 'success');
                    if (RATE_LIMIT_MINUTES > 0) startCooldownTimer(RATE_LIMIT_MINUTES);
                } else {
                    showMessage(result.message || 'Erreur lors du placement du pixel.', 'error');
                    const matches = result.message && result.message.match(/attendre (\d+) minute\(s\)/);
                    if (matches && matches[1]) startCooldownTimer(parseInt(matches[1], 10));
                }
            } catch (error) {
                console.error('Erreur lors de l\'ajout du pixel :', error);
                showMessage('Erreur de connexion au serveur.', 'error');
            }
        }

        async function loadAllPixels() {
            try {
                const response = await fetch(`${APPS_SCRIPT_API_URL}?action=getPixels`);
                const pixelsData = await response.json();
                if (pixelsData && Array.isArray(pixelsData)) {
                    pixelsData.forEach(p => updatePixelOnGrid(p.x, p.y, p.color, p.user));
                } else console.warn("Aucun pixel chargé ou format incorrect.");

                const countResponse = await fetch(`${APPS_SCRIPT_API_URL}?action=countPixels`);
                const countResult = await countResponse.json();
                if (countResult.count >= totalPixelsInGrid) {
                    // L'archivage se déclenche maintenant via d'autres flux (chargement, test)
                }
            } catch (error) {
                console.error('Erreur lors du chargement des pixels :', error);
                showMessage('Erreur lors du chargement des pixels.', 'error');
            }
        }
        
        async function archiveCurrentGridAndReset() {
            showMessage('Archivage des données en cours...', 'info');
            archiveOkBtn.disabled = true; 
            exportGridHtmlBtn.disabled = true; 

            try {
                const gasResponse = await fetch(`${APPS_SCRIPT_API_URL}?action=archiveGrid`); 
                const result = await gasResponse.json();
                if (result.success) {
                    showMessage(result.message, 'success'); 
                    
                    await exportGridAsHTML(true); 

                    resetGridClientSide(); 
                } else {
                    showMessage(result.message || 'Erreur lors de l\'archivage des données.', 'error');
                }
            } catch (error) {
                console.error('Erreur lors de l\'archivage des données :', error);
                showMessage('Erreur de connexion lors de l\'archivage des données.', 'error');
            } finally {
                archiveOkBtn.disabled = false; 
                exportGridHtmlBtn.disabled = false; 
            }
        }


        async function fillGridForTesting() {
            showMessage('Remplissage de la grille en cours...', 'info');
            fillGridTestBtn.disabled = true; 
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=fillTestGrid&gridWidth=${gridSize}&gridHeight=${totalGridHeightPixels}`;
                const response = await fetch(url); 
                const result = await response.json();
                if (result.success) {
                    showMessage(result.message, 'success');
                    await loadAllPixels(); 
                    const countResponse = await fetch(`${APPS_SCRIPT_API_URL}?action=countPixels`);
                    const countResult = await countResponse.json();
                    if (countResult.count >= totalPixelsInGrid) {
                        showMessage('Grille de test pleine, déclenchement de l\'archivage automatique...', 'info');
                        await archiveCurrentGridAndReset(); 
                    }
                } else {
                    showMessage(result.message || 'Erreur lors du remplissage de test.', 'error');
                }
            } catch (error) {
                console.error('Erreur lors du remplissage de test :', error);
                showMessage('Erreur de connexion lors du remplissage de test.', 'error');
            } finally {
                fillGridTestBtn.disabled = false; 
            }
        }

        // MODIFIÉ : Ajout de l'affichage du pseudo dans l'export HTML
        async function exportGridAsHTML(isAutoExport = false) {
            if (!isAutoExport) {
                showMessage('Préparation de l\'export HTML vers Drive...', 'info');
                exportGridHtmlBtn.disabled = true;
            } else {
                showMessage('Envoi de l\'archive HTML vers Drive...', 'info');
            }

            const exportPixelSize = 20; // Augmenter un peu la taille pour la lisibilité du pseudo
            const gridWidthPx = gridSize * exportPixelSize;
            const gridHeightPx = totalGridHeightPixels * exportPixelSize;

            let htmlGeneratedContent = `
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Archive PixelWar - ${new Date().toLocaleString('fr-FR')}</title>
    <style>
        body { margin: 20px; font-family: sans-serif; background-color: #f0f0f0; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: calc(100vh - 40px); }
        h1 { margin-bottom: 20px; }
        .pixel-grid-export {
            display: grid;
            grid-template-columns: repeat(${gridSize}, ${exportPixelSize}px);
            grid-template-rows: repeat(${totalGridHeightPixels}, ${exportPixelSize}px);
            width: ${gridWidthPx}px;
            height: ${gridHeightPx}px;
            border: 1px solid #ccc;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .pixel-export {
            width: ${exportPixelSize}px;
            height: ${exportPixelSize}px;
            border: 0.5px solid #eee; 
            box-sizing: border-box;
            /* Styles pour afficher le pseudo */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px; /* Ajuster la taille pour la lisibilité */
            color: rgba(0,0,0,0.5); /* Couleur du texte pour le pseudo, semi-transparent */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            line-height: 1;
        }
        .pixel-export.dark-bg { /* Classe pour les fonds foncés, pour un texte clair */
            color: rgba(255,255,255,0.6);
        }
    </style>
</head>
<body>
    <h1>Archive PixelWar du ${new Date().toLocaleDateString('fr-FR')} à ${new Date().toLocaleTimeString('fr-FR')}</h1>
    <div class="pixel-grid-export">`;

            const pixels = pixelGrid.querySelectorAll('.pixel');
            pixels.forEach(pixel => {
                const color = pixel.style.backgroundColor || 'white'; 
                const user = pixel.dataset.user || ''; // Récupérer le pseudo
                let userDisplay = user;
                if (user === 'Vide' || user === 'Anonyme') { // Ne pas afficher "Vide" ou "Anonyme"
                    userDisplay = '';
                } else if (user.length > 3) { // Tronquer les pseudos longs pour l'affichage
                    userDisplay = user.substring(0,2) + '.';
                }

                // Déterminer si le fond est sombre pour ajuster la couleur du texte du pseudo
                let isDarkBg = false;
                if (color && color !== 'white' && color !== '#fff' && color !== 'rgb(255, 255, 255)') {
                    try {
                        // Tentative de conversion de la couleur en RGB pour évaluer la luminosité
                        let r, g, b;
                        if (color.startsWith('#')) {
                            const hex = color.replace('#', '');
                            r = parseInt(hex.substring(0,2), 16);
                            g = parseInt(hex.substring(2,4), 16);
                            b = parseInt(hex.substring(4,6), 16);
                        } else if (color.startsWith('rgb')) {
                            const parts = color.match(/\d+/g);
                            if (parts && parts.length >=3) {
                                r = parseInt(parts[0]);
                                g = parseInt(parts[1]);
                                b = parseInt(parts[2]);
                            }
                        }
                        if (r !== undefined && g !== undefined && b !== undefined) {
                            // Formule simple de luminosité (0-255)
                            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                            if (brightness < 128) { // Seuil pour considérer un fond comme sombre
                                isDarkBg = true;
                            }
                        }
                    } catch (e) { /* ignorer les erreurs de parsing de couleur */ }
                }
                const darkBgClass = isDarkBg ? 'dark-bg' : '';

                htmlGeneratedContent += `<div class="pixel-export ${darkBgClass}" style="background-color: ${color};" title="${user}">${userDisplay}</div>`;
            });

            htmlGeneratedContent += `
    </div>
</body>
</html>`;
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `pixelwar_archive_${timestamp}.html`;

            return new Promise(async (resolve, reject) => {
                try {
                    const response = await fetch(APPS_SCRIPT_API_URL, {
                        method: 'POST',
                        headers: {
                           'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            action: 'saveHtmlToDrive', 
                            htmlContent: htmlGeneratedContent,
                            filename: filename
                        })
                    });
                    const result = await response.json();

                    if (result.success) {
                        showMessage(result.message || `HTML sauvegardé sur Drive: ${filename}`, 'success');
                        resolve();
                    } else {
                        throw new Error(result.message || 'Erreur inconnue lors de la sauvegarde sur Drive.');
                    }
                } catch (error) {
                    console.error("Erreur lors de l'envoi du HTML à Google Drive :", error);
                    showMessage(`Erreur Drive: ${error.message}`, 'error');
                    reject(error);
                } finally {
                    if (!isAutoExport) {
                        exportGridHtmlBtn.disabled = false;
                    }
                }
            });
        }


        for (let i = 0; i < gridSize * totalGridHeightPixels; i++) { 
            const pixel = document.createElement('div');
            pixel.classList.add('pixel');
            const x = i % gridSize, y = Math.floor(i / gridSize);
            pixel.dataset.x = x; pixel.dataset.y = y;
            const tooltip = document.createElement('span');
            tooltip.classList.add('tooltip'); tooltip.textContent = "Vide";
            pixel.appendChild(tooltip);
            pixel.dataset.color = "#fff"; pixel.dataset.user = "Vide"; // Initialiser dataset.user
            pixelGrid.appendChild(pixel);
            pixel.addEventListener('click', async () => {
                if (RATE_LIMIT_MINUTES > 0 && !timerContainer.classList.contains('hidden')) {
                    showMessage("Veuillez attendre la fin du minuteur.", "info"); return;
                }
                const selectedColor = await showColorModal();
                if (selectedColor === null) return;
                currentColor = selectedColor;
                const userName = await showUsernameModal();
                if (userName === null) return;
                addPixel(x, y, currentColor, userName);
            });
        }

        fillGridTestBtn.addEventListener('click', fillGridForTesting);
        exportGridHtmlBtn.addEventListener('click', () => exportGridAsHTML(false)); 


        window.addEventListener('load', async () => { 
            setPixelGridSize(); 
            centerGrid(); 
            await loadAllPixels(); 

            const countResponse = await fetch(`${APPS_SCRIPT_API_URL}?action=countPixels`);
            const countResult = await countResponse.json();
            if (countResult.count >= totalPixelsInGrid) {
                 showMessage('Grille détectée comme pleine au chargement, proposition d\'archivage...', 'info');
                if (await showArchiveModal()) { 
                   await archiveCurrentGridAndReset();
                }
            }
        });
        window.addEventListener('resize', () => { setPixelGridSize(); centerGrid(); });
        
        setInterval(loadAllPixels, 7000); 
    </script>
</body>
</html>
