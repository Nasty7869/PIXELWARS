<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mon PixelWar Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Styles CSS personnalisés pour la grille et les pixels */
        body {
            font-family: 'Inter', sans-serif; /* Utilisation de la police Inter */
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0; /* Supprime la marge par défaut du body */
            background-color: #e2e8f0; /* Un gris-bleu plus doux */
            min-height: 100vh;
            justify-content: center; /* Centre le contenu verticalement */
            padding: 0; /* Supprime le padding du body pour que la grille puisse prendre toute la place */
            box-sizing: border-box; /* Inclut le padding dans la taille totale */
            overflow: hidden; /* Empêche le défilement du body pour le zoom */
        }

        #pixel-grid {
            display: grid;
            border: 1px solid #cbd5e1; /* Bordure plus douce */
            background-color: white;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); /* Ombre plus prononcée */
            position: relative;
            border-radius: 0; /* Supprime les bords arrondis du tableau */
            overflow: hidden; /* Pour que les pixels ne dépassent pas les bords */
            flex-grow: 1; /* Permet à la grille de prendre l'espace disponible */
            cursor: grab; /* Curseur pour indiquer que la grille est déplaçable */
        }

        .pixel {
            background-color: #fff;
            border: 0.5px solid #f0f0f0; /* Bordure de pixel très légère */
            position: relative;
            cursor: pointer;
            border-radius: 2px; /* Bords légèrement arrondis pour les pixels */
            transition: background-color 0.1s ease-in-out; /* Transition douce pour la couleur */
            box-shadow: 0 0 5px rgba(0,0,0,0); /* Initial shadow for glow effect */
        }

        .pixel.placed {
            cursor: not-allowed;
        }

        /* Style for the glow effect on images */
        .pixel.placed:hover {
            box-shadow: 0 0 15px 5px rgba(76, 175, 80, 0.7); /* Green glow on hover for placed pixels */
            z-index: 1; /* Bring to front on hover */
        }

        /* Style pour l'infobulle */
        .pixel .tooltip {
            visibility: hidden;
            width: auto;
            background-color: rgba(0, 0, 0, 0.8); /* Fond plus opaque */
            color: #fff;
            text-align: center;
            border-radius: 0.5rem; /* Bords arrondis pour l'infobulle */
            padding: 5px 8px;
            position: absolute;
            z-index: 1000; /* Z-index très élevé pour s'assurer qu'il est au-dessus */
            bottom: 100%; /* Apparaît au-dessus du pixel */
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px; /* Plus d'espace au-dessus du pixel */
            white-space: nowrap;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            pointer-events: none; /* Permet de cliquer à travers l'infobulle */
        }

        .pixel:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        /* Styles spécifiques pour les modales */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000; /* Z-index très élevé pour les modales */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            max-width: 90%;
            width: 400px;
            text-align: center;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
        }

        .modal-overlay.show .modal-content {
            transform: translateY(0);
        }

        /* Style pour les messages temporaires */
        #message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4CAF50; /* Vert par défaut */
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #message-box.show {
            opacity: 1;
            visibility: visible;
        }
        #message-box.error {
            background-color: #f44336; /* Rouge pour les erreurs */
        }
        #message-box.info {
            background-color: #2196F3; /* Bleu pour les infos */
        }

        /* Style pour la modale d'archivage */
        #archive-modal .modal-content {
            width: 500px;
        }

        /* Style pour le timer */
        #cooldown-timer {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 1.1rem;
            z-index: 9999; /* Moins que les modales, plus que la grille */
            display: none; /* Caché par défaut */
        }

        /* Style pour les boutons de contrôle en bas */
        #control-buttons {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;
            display: flex;
            gap: 15px;
        }

        /* Styles pour la modale de liste d'archives */
        #list-archives-modal .modal-content {
            width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #archives-list {
            list-style: none;
            padding: 0;
            text-align: left;
        }
        #archives-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }
        #archives-list li:last-child {
            border-bottom: none;
        }
        #archives-list li .archive-info {
            flex-grow: 1;
        }
        #archives-list li .archive-actions {
            display: flex;
            gap: 10px;
        }

        /* Styles pour la modale de visualisation d'archive */
        #view-archive-modal .modal-content {
            width: auto; /* Laisser la grille définir la largeur */
            max-width: 95vw;
            max-height: 95vh;
            overflow: auto;
            padding: 1rem;
        }
        #archived-pixel-grid {
            display: grid;
            border: 1px solid #cbd5e1;
            background-color: white;
            box-shadow: 0 5px 10px rgba(0,0,0,0.05);
            margin: 0 auto; /* Centrer la grille archivée */
        }
        .archived-pixel {
            border: 0.5px solid #f0f0f0;
            position: relative;
        }
        .archived-pixel .tooltip {
            visibility: hidden;
            width: auto;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            text-align: center;
            border-radius: 0.5rem;
            padding: 3px 6px;
            position: absolute;
            z-index: 1000;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 5px;
            white-space: nowrap;
            font-size: 10px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            pointer-events: none;
        }
        .archived-pixel:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center min-h-screen">
    <div id="pixel-grid"></div>

    <div id="color-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Choisissez une couleur</h2>
            <div id="modal-palette" class="flex justify-center flex-wrap gap-2 mb-6">
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: red;" data-color="red"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: blue;" data-color="blue"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: green;" data-color="green"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: yellow;" data-color="yellow"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: black;" data-color="black"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: white;" data-color="white"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: purple;" data-color="purple"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: orange;" data-color="orange"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: cyan;" data-color="cyan"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: magenta;" data-color="magenta"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: limegreen;" data-color="limegreen"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: brown;" data-color="brown"></div>
            </div>
            <button id="color-modal-cancel-btn" class="px-6 py-3 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">Annuler</button>
        </div>
    </div>

    <div id="username-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Quel est votre pseudo ?</h2>
            <input type="text" id="username-input" class="w-full p-3 border border-gray-300 rounded-lg mb-6 text-lg focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Entrez votre pseudo ici..." maxlength="20">
            <div class="flex justify-center space-x-4">
                <button id="modal-ok-btn" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">Envoyer</button>
                <button id="modal-cancel-btn" class="px-6 py-3 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">Annuler</button>
            </div>
        </div>
    </div>

    <div id="archive-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Grille Complète !</h2>
            <p class="text-gray-700 mb-4">La grille de pixels est entièrement remplie. Donnez un nom à cette toile pour l'archiver :</p>
            <input type="text" id="canvas-name-input" class="w-full p-3 border border-gray-300 rounded-lg mb-6 text-lg focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Nom de la toile" maxlength="30">
            <div class="flex justify-center space-x-4">
                <button id="archive-ok-btn" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">Archiver la Toile</button>
                <button id="archive-cancel-btn" class="px-6 py-3 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">Annuler</button>
            </div>
        </div>
    </div>

    <div id="list-archives-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Toiles Archivées</h2>
            <ul id="archives-list" class="mb-6">
                <li class="text-gray-500">Aucune archive trouvée.</li>
            </ul>
            <button id="list-archives-close-btn" class="px-6 py-3 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">Fermer</button>
        </div>
    </div>

    <div id="view-archive-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="view-archive-title" class="text-2xl font-bold text-gray-800 mb-4"></h2>
            <div id="archived-pixel-grid" class="mb-6"></div>
            <button id="view-archive-close-btn" class="px-6 py-3 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">Fermer</button>
        </div>
    </div>

    <div id="message-box" class="hidden"></div>

    <div id="cooldown-timer"></div>

    <div id="control-buttons">
        <button id="fill-grid-btn" class="px-6 py-3 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2">Remplir la Grille (Test)</button>
        <button id="view-archives-btn" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">Voir les Archives</button>
    </div>

    <script>
        // L'URL de votre application web Apps Script déployée, utilisée comme API.
        const APPS_SCRIPT_API_URL = '<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mon PixelWar Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Styles CSS personnalisés pour la grille et les pixels */
        body {
            font-family: 'Inter', sans-serif; /* Utilisation de la police Inter */
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0; /* Supprime la marge par défaut du body */
            background-color: #e2e8f0; /* Un gris-bleu plus doux */
            min-height: 100vh;
            justify-content: center; /* Centre le contenu verticalement */
            padding: 0; /* Supprime le padding du body pour que la grille puisse prendre toute la place */
            box-sizing: border-box; /* Inclut le padding dans la taille totale */
            overflow: hidden; /* Empêche le défilement du body pour le zoom */
        }

        #pixel-grid {
            display: grid;
            border: 1px solid #cbd5e1; /* Bordure plus douce */
            background-color: white;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); /* Ombre plus prononcée */
            position: relative;
            border-radius: 0; /* Supprime les bords arrondis du tableau */
            overflow: hidden; /* Pour que les pixels ne dépassent pas les bords */
            flex-grow: 1; /* Permet à la grille de prendre l'espace disponible */
            cursor: grab; /* Curseur pour indiquer que la grille est déplaçable */
        }

        .pixel {
            background-color: #fff;
            border: 0.5px solid #f0f0f0; /* Bordure de pixel très légère */
            position: relative;
            cursor: pointer;
            border-radius: 2px; /* Bords légèrement arrondis pour les pixels */
            transition: background-color 0.1s ease-in-out; /* Transition douce pour la couleur */
            box-shadow: 0 0 5px rgba(0,0,0,0); /* Initial shadow for glow effect */
        }

        .pixel.placed {
            cursor: not-allowed;
        }

        /* Style for the glow effect on images */
        .pixel.placed:hover {
            box-shadow: 0 0 15px 5px rgba(76, 175, 80, 0.7); /* Green glow on hover for placed pixels */
            z-index: 1; /* Bring to front on hover */
        }

        /* Style pour l'infobulle */
        .pixel .tooltip {
            visibility: hidden;
            width: auto;
            background-color: rgba(0, 0, 0, 0.8); /* Fond plus opaque */
            color: #fff;
            text-align: center;
            border-radius: 0.5rem; /* Bords arrondis pour l'infobulle */
            padding: 5px 8px;
            position: absolute;
            z-index: 1000; /* Z-index très élevé pour s'assurer qu'il est au-dessus */
            bottom: 100%; /* Apparaît au-dessus du pixel */
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px; /* Plus d'espace au-dessus du pixel */
            white-space: nowrap;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            pointer-events: none; /* Permet de cliquer à travers l'infobulle */
        }

        .pixel:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        /* Styles spécifiques pour les modales */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000; /* Z-index très élevé pour les modales */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            max-width: 90%;
            width: 400px;
            text-align: center;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
        }

        .modal-overlay.show .modal-content {
            transform: translateY(0);
        }

        /* Style pour les messages temporaires */
        #message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4CAF50; /* Vert par défaut */
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #message-box.show {
            opacity: 1;
            visibility: visible;
        }
        #message-box.error {
            background-color: #f44336; /* Rouge pour les erreurs */
        }
        #message-box.info {
            background-color: #2196F3; /* Bleu pour les infos */
        }

        /* Style pour la modale d'archivage */
        #archive-modal .modal-content {
            width: 500px;
        }

        /* Style pour le timer */
        #cooldown-timer {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 1.1rem;
            z-index: 9999; /* Moins que les modales, plus que la grille */
            display: none; /* Caché par défaut */
        }

        /* Style pour les boutons de contrôle en bas */
        #control-buttons {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;
            display: flex;
            gap: 15px;
        }

        /* Styles pour la modale de liste d'archives */
        #list-archives-modal .modal-content {
            width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #archives-list {
            list-style: none;
            padding: 0;
            text-align: left;
        }
        #archives-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }
        #archives-list li:last-child {
            border-bottom: none;
        }
        #archives-list li .archive-info {
            flex-grow: 1;
        }
        #archives-list li .archive-actions {
            display: flex;
            gap: 10px;
        }

        /* Styles pour la modale de visualisation d'archive */
        #view-archive-modal .modal-content {
            width: auto; /* Laisser la grille définir la largeur */
            max-width: 95vw;
            max-height: 95vh;
            overflow: auto;
            padding: 1rem;
        }
        #archived-pixel-grid {
            display: grid;
            border: 1px solid #cbd5e1;
            background-color: white;
            box-shadow: 0 5px 10px rgba(0,0,0,0.05);
            margin: 0 auto; /* Centrer la grille archivée */
        }
        .archived-pixel {
            border: 0.5px solid #f0f0f0;
            position: relative;
        }
        .archived-pixel .tooltip {
            visibility: hidden;
            width: auto;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            text-align: center;
            border-radius: 0.5rem;
            padding: 3px 6px;
            position: absolute;
            z-index: 1000;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 5px;
            white-space: nowrap;
            font-size: 10px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            pointer-events: none;
        }
        .archived-pixel:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center min-h-screen">
    <div id="pixel-grid"></div>

    <div id="color-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Choisissez une couleur</h2>
            <div id="modal-palette" class="flex justify-center flex-wrap gap-2 mb-6">
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: red;" data-color="red"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: blue;" data-color="blue"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: green;" data-color="green"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: yellow;" data-color="yellow"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: black;" data-color="black"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: white;" data-color="white"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: purple;" data-color="purple"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: orange;" data-color="orange"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: cyan;" data-color="cyan"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: magenta;" data-color="magenta"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: limegreen;" data-color="limegreen"></div>
                <div class="color-box w-10 h-10 border-2 border-gray-300 rounded-full cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-md" style="background-color: brown;" data-color="brown"></div>
            </div>
            <button id="color-modal-cancel-btn" class="px-6 py-3 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">Annuler</button>
        </div>
    </div>

    <div id="username-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Quel est votre pseudo ?</h2>
            <input type="text" id="username-input" class="w-full p-3 border border-gray-300 rounded-lg mb-6 text-lg focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Entrez votre pseudo ici..." maxlength="20">
            <div class="flex justify-center space-x-4">
                <button id="modal-ok-btn" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">Envoyer</button>
                <button id="modal-cancel-btn" class="px-6 py-3 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">Annuler</button>
            </div>
        </div>
    </div>

    <div id="archive-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Grille Complète !</h2>
            <p class="text-gray-700 mb-4">La grille de pixels est entièrement remplie. Donnez un nom à cette toile pour l'archiver :</p>
            <input type="text" id="canvas-name-input" class="w-full p-3 border border-gray-300 rounded-lg mb-6 text-lg focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Nom de la toile" maxlength="30">
            <div class="flex justify-center space-x-4">
                <button id="archive-ok-btn" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">Archiver la Toile</button>
                <button id="archive-cancel-btn" class="px-6 py-3 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">Annuler</button>
            </div>
        </div>
    </div>

    <div id="list-archives-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Toiles Archivées</h2>
            <ul id="archives-list" class="mb-6">
                <li class="text-gray-500">Aucune archive trouvée.</li>
            </ul>
            <button id="list-archives-close-btn" class="px-6 py-3 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">Fermer</button>
        </div>
    </div>

    <div id="view-archive-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="view-archive-title" class="text-2xl font-bold text-gray-800 mb-4"></h2>
            <div id="archived-pixel-grid" class="mb-6"></div>
            <button id="view-archive-close-btn" class="px-6 py-3 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">Fermer</button>
        </div>
    </div>

    <div id="message-box" class="hidden"></div>

    <div id="cooldown-timer"></div>

    <div id="control-buttons">
        <button id="fill-grid-btn" class="px-6 py-3 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2">Remplir la Grille (Test)</button>
        <button id="view-archives-btn" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">Voir les Archives</button>
    </div>

    <script>
        // L'URL de votre application web Apps Script déployée, utilisée comme API.
        const APPS_SCRIPT_API_URL = 'https://script.google.com/macros/s/AKfycbwBrie_l2D8Ub4dQjm5kMKeBT6XRbWDvFnAPu3b06UhFnaoHCObq0tZB3qE_UcmpiXS/exec';

        const gridSize = 50; // Nombre de pixels sur un côté de la grille (50x50)
        const pixelGrid = document.getElementById('pixel-grid');
        let currentColor = 'red'; // Couleur par défaut

        // Éléments des modales
        const colorModal = document.getElementById('color-modal');
        const modalPalette = document.getElementById('modal-palette');
        const colorModalCancelBtn = document.getElementById('color-modal-cancel-btn');

        const usernameModal = document.getElementById('username-modal');
        const usernameInput = document.getElementById('username-input');
        const modalOkBtn = document.getElementById('modal-ok-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        // La modale d'archive n'est plus utilisée pour la confirmation automatique, mais pour l'archivage manuel par nom
        const archiveModal = document.getElementById('archive-modal');
        const canvasNameInput = document.getElementById('canvas-name-input');
        const archiveOkBtn = document.getElementById('archive-ok-btn');
        const archiveCancelBtn = document.getElementById('archive-cancel-btn');


        const listArchivesModal = document.getElementById('list-archives-modal');
        const archivesList = document.getElementById('archives-list');
        const listArchivesCloseBtn = document.getElementById('list-archives-close-btn');

        const viewArchiveModal = document.getElementById('view-archive-modal');
        const viewArchiveTitle = document.getElementById('view-archive-title');
        const archivedPixelGrid = document.getElementById('archived-pixel-grid');
        const viewArchiveCloseBtn = document.getElementById('view-archive-close-btn');


        const messageBox = document.getElementById('message-box');
        const cooldownTimerDisplay = document.getElementById('cooldown-timer');
        const fillGridBtn = document.getElementById('fill-grid-btn');
        const viewArchivesBtn = document.getElementById('view-archives-btn');

        let resolveColorModalPromise;
        let resolveUsernameModalPromise;
        let resolveArchiveModalPromise; // Pour l'archivage manuel par nom

        let currentZoomLevel = 1.0; // Niveau de zoom actuel
        const zoomStep = 0.1; // Pas de zoom
        const minZoom = 1.0; // Zoom minimum (la grille ne peut pas être plus petite que la taille initiale)
        const maxZoom = 5.0; // Zoom maximum

        // Variables pour le déplacement de la grille
        let isDragging = false;
        let startX, startY;
        let currentTranslateX = 0;
        let currentTranslateY = 0;

        // Définir les ratios pour le calcul de la grille
        const targetRatioWidth = 16;
        const targetRatioHeight = 9;
        // Calculer le nombre total de pixels en hauteur pour maintenir le ratio 16:9
        const totalGridHeightPixels = Math.round(gridSize * (targetRatioHeight / targetRatioWidth));
        const totalPixelsInGrid = gridSize * totalGridHeightPixels; // Nombre total de pixels attendus dans la grille

        const RATE_LIMIT_SECONDS = 3 * 60; // 3 minutes en secondes, doit correspondre à Code.gs

        // Fonction pour afficher un message temporaire
        function showMessage(message, type = 'success') {
            messageBox.textContent = message;
            messageBox.className = `message-box show ${type}`;
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 3000); // Le message disparaît après 3 secondes
        }

        // Fonction pour calculer et appliquer la taille des pixels et de la grille avec un ratio 16:9
        function setPixelGridSize() {
            // Utilise la largeur et la hauteur du viewport pour maximiser l'espace
            const availableWidth = document.documentElement.clientWidth;
            const availableHeight = document.documentElement.clientHeight;

            let pixelSize;

            // Calculer la taille d'un pixel en fonction de la contrainte de largeur et de hauteur
            const pixelSizeByWidth = availableWidth / gridSize;
            const pixelSizeByHeight = availableHeight / totalGridHeightPixels;

            // Choisir la plus petite taille de pixel pour s'assurer que la grille entière rentre
            pixelSize = Math.min(pixelSizeByWidth, pixelSizeByHeight);

            // Appliquer le niveau de zoom
            pixelSize *= currentZoomLevel;
            
            // Appliquer la taille à la grille
            pixelGrid.style.width = `${pixelSize * gridSize}px`;
            pixelGrid.style.height = `${pixelSize * totalGridHeightPixels}px`;

            pixelGrid.style.gridTemplateColumns = `repeat(${gridSize}, ${pixelSize}px)`;
            pixelGrid.style.gridTemplateRows = `repeat(${totalGridHeightPixels}, ${pixelSize}px)`;

            centerGrid();
        }

        // Fonction pour centrer la grille
        function centerGrid() {
            const gridRect = pixelGrid.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Calcule le décalage nécessaire pour centrer la grille
            currentTranslateX = (viewportWidth / 2) - (gridRect.width / 2);
            currentTranslateY = (viewportHeight / 2) - (gridRect.height / 2);
            
            // Applique la translation
            pixelGrid.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px)`;
        }

        // Gestion du zoom avec la molette de la souris
        pixelGrid.addEventListener('wheel', (event) => {
            event.preventDefault(); // Empêche le défilement de la page

            const oldZoomLevel = currentZoomLevel;

            if (event.deltaY < 0) { // Molette vers le haut (zoom avant)
                currentZoomLevel = Math.min(maxZoom, currentZoomLevel + zoomStep);
            } else { // Molette vers le bas (zoom arrière)
                currentZoomLevel = Math.max(minZoom, currentZoomLevel - zoomStep);
            }

            if (oldZoomLevel !== currentZoomLevel) {
                setPixelGridSize(); // Recalcule la taille de la grille avec le nouveau zoom
            }
        });

        // Gestion du déplacement de la grille (drag) avec le clic molette
        pixelGrid.addEventListener('mousedown', (event) => {
            // event.button === 1 correspond au clic du bouton central (molette)
            if (event.button === 1) {
                event.preventDefault(); // Empêche le comportement par défaut du clic molette (autoscroll)
                isDragging = true;
                startX = event.clientX - currentTranslateX;
                startY = event.clientY - currentTranslateY;
                pixelGrid.style.cursor = 'grabbing';
            }
        });

        window.addEventListener('mousemove', (event) => {
            if (!isDragging) return;
            event.preventDefault(); // Empêche la sélection de texte lors du glisser-déposer
            currentTranslateX = event.clientX - startX;
            currentTranslateY = event.clientY - startY;
            pixelGrid.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px)`;
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            pixelGrid.style.cursor = 'grab';
        });


        // --- Fonctions pour gérer les modales ---
        function showColorModal() {
            return new Promise(resolve => {
                resolveColorModalPromise = resolve;
                colorModal.classList.add('show');
            });
        }

        function showUsernameModal() {
            return new Promise(resolve => {
                resolveUsernameModalPromise = resolve;
                usernameInput.value = '';
                usernameModal.classList.add('show');
                usernameInput.focus();
            });
        }

        // Modale d'archivage manuel par nom
        function showManualArchiveModal() {
            return new Promise(resolve => {
                resolveArchiveModalPromise = resolve;
                archiveModal.classList.add('show');
                canvasNameInput.value = ''; // Réinitialiser le champ de nom
                canvasNameInput.focus();
            });
        }

        function showListArchivesModal() {
            return new Promise(async resolve => {
                listArchivesModal.classList.add('show');
                await populateArchivesList();
                resolve();
            });
        }

        function showViewArchiveModal(title, pixels) {
            viewArchiveTitle.textContent = title;
            renderArchivedGrid(pixels);
            viewArchiveModal.classList.add('show');
        }

        // Gestionnaire pour la sélection de couleur dans la modale
        modalPalette.addEventListener('click', (event) => {
            if (event.target.classList.contains('color-box')) {
                const selectedColor = event.target.dataset.color;
                colorModal.classList.remove('show');
                resolveColorModalPromise(selectedColor); // Résout la promesse avec la couleur choisie
            }
        });

        // Gestionnaire pour le bouton Annuler de la modale de couleur
        colorModalCancelBtn.addEventListener('click', () => {
            colorModal.classList.remove('show');
            resolveColorModalPromise(null); // Résout la promesse avec null si annulé
        });

        // Gestionnaire pour le bouton OK de la modale de pseudo
        modalOkBtn.addEventListener('click', () => {
            const userName = usernameInput.value.trim();
            usernameModal.classList.remove('show');
            resolveUsernameModalPromise(userName === '' ? 'Anonyme' : userName);
        });

        // Gestionnaire pour le bouton Annuler de la modale de pseudo
        modalCancelBtn.addEventListener('click', () => {
            usernameModal.classList.remove('show');
            resolveUsernameModalPromise(null);
        });

        // Gérer la touche Entrée dans l'input de la modale de pseudo
        usernameInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                modalOkBtn.click();
            }
        });

        // Gestionnaire pour le bouton Archiver de la modale d'archivage (sur Google Sheet)
        archiveOkBtn.addEventListener('click', async () => {
            const canvasName = canvasNameInput.value.trim();
            if (!canvasName) {
                showMessage('Veuillez donner un nom à la toile.', 'error');
                return;
            }
            archiveModal.classList.remove('show');
            resolveArchiveModalPromise(canvasName); // Résout la promesse avec le nom
        });

        // Gestionnaire pour le bouton Annuler de la modale d'archivage
        archiveCancelBtn.addEventListener('click', () => {
            archiveModal.classList.remove('show');
            resolveArchiveModalPromise(null); // Résout la promesse avec null si annulé
        });

        // Gérer la touche Entrée dans l'input de la modale de nom de toile
        canvasNameInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                archiveOkBtn.click();
            }
        });

        // Fermer la modale de liste d'archives
        listArchivesCloseBtn.addEventListener('click', () => {
            listArchivesModal.classList.remove('show');
        });

        // Fermer la modale de visualisation d'archive
        viewArchiveCloseBtn.addEventListener('click', () => {
            viewArchiveModal.classList.remove('show');
        });


        // --- Fonctions de logique métier ---
        function updatePixelOnGrid(x, y, color, user) {
            const pixelElement = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (pixelElement) {
                pixelElement.style.backgroundColor = color;
                pixelElement.dataset.color = color;
                pixelElement.dataset.user = user;
                pixelElement.querySelector('.tooltip').textContent = user;
                pixelElement.classList.add('placed');
            }
        }

        async function addPixel(x, y, color, userName) {
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=addPixel&x=${x}&y=${y}&color=${color}&user=${userName}`;
                const response = await fetch(url, {
                    method: 'GET',
                });
                const result = await response.json(); // La réponse inclura { success: true/false, message, pixel }

                if (result.success) {
                    updatePixelOnGrid(result.pixel.x, result.pixel.y, result.pixel.color, result.pixel.user);
                    localStorage.setItem(`lastPixelTime_${userName}`, Date.now()); // Enregistre le timestamp localement
                    updateCooldownTimer(userName); // Met à jour le timer immédiatement
                    showMessage('Pixel placé avec succès !', 'success');
                } else {
                    showMessage(result.message || 'Erreur lors du placement du pixel.', 'error');
                }
            } catch (error) {
                console.error('Erreur lors de l\'ajout du pixel :', error);
                showMessage('Erreur de connexion au serveur.', 'error');
            }
        }

        async function loadAllPixels() {
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=getPixels`;
                const response = await fetch(url);
                const pixels = await response.json();
                
                // Réinitialiser la grille visuellement avant de la remplir
                document.querySelectorAll('.pixel').forEach(pixel => {
                    pixel.style.backgroundColor = '#fff';
                    pixel.dataset.color = '#fff';
                    pixel.dataset.user = 'Vide';
                    pixel.querySelector('.tooltip').textContent = 'Vide';
                    pixel.classList.remove('placed');
                });

                pixels.forEach(p => {
                    updatePixelOnGrid(p.x, p.y, p.color, p.user);
                });

                // Après le chargement, vérifier si la grille est pleine
                const countUrl = `${APPS_SCRIPT_API_URL}?action=countPixels`;
                const countResponse = await fetch(countUrl);
                const countResult = await countResponse.json();

                if (countResult.count >= totalPixelsInGrid) {
                    // Afficher la modale d'archivage manuel (si ce n'est pas déjà affiché)
                    if (!archiveModal.classList.contains('show')) {
                        const archiverUser = usernameInput.value.trim() || 'Anonyme'; // Utilise le pseudo actuel ou "Anonyme"
                        const canvasName = await showManualArchiveModal(); // Demande le nom de la toile
                        if (canvasName) {
                            showMessage(`Grille pleine ! Archivage de "${canvasName}" en cours...`, 'info');
                            await archiveCurrentGridToSheet(canvasName, archiverUser);
                        } else {
                            showMessage('Archivage annulé.', 'info');
                        }
                    }
                }

            } catch (error) {
                console.error('Erreur lors du chargement des pixels :', error);
                showMessage('Erreur lors du chargement des pixels.', 'error');
            }
        }

        async function archiveCurrentGridToSheet(canvasName, archiverUser) {
            showMessage(`Archivage de "${canvasName}" en cours...`, 'info');
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=archiveGridToSheet`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ canvasName: canvasName, archiverUser: archiverUser })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Erreur réseau lors de l'archivage sur feuille: ${response.status} ${response.statusText} - ${errorText}`);
                }

                const result = await response.json();
                if (result.success) {
                    showMessage(result.message, 'success');
                    loadAllPixels(); // Recharger la grille principale après archivage et effacement
                } else {
                    showMessage(result.message || 'Erreur lors de l\'archivage sur Google Sheet.', 'error');
                }
            } catch (error) {
                console.error('Erreur lors de l\'archivage sur Google Sheet :', error);
                showMessage('Erreur de connexion lors de l\'archivage sur Google Sheet.', 'error');
            }
        }

        async function populateArchivesList() {
            archivesList.innerHTML = '<li class="text-gray-500">Chargement des archives...</li>';
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=getArchivedCanvases`;
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Erreur réseau lors de la récupération des archives: ${response.status} ${response.statusText}`);
                }
                const archives = await response.json();

                archivesList.innerHTML = ''; // Vider la liste
                if (archives.length === 0) {
                    archivesList.innerHTML = '<li class="text-gray-500">Aucune archive trouvée.</li>';
                } else {
                    archives.forEach(archive => {
                        const li = document.createElement('li');
                        const formattedDate = new Date(archive.timestamp).toLocaleString();
                        li.innerHTML = `
                            <div class="archive-info">
                                <strong class="text-gray-900">${archive.canvasName}</strong>
                                <span class="text-gray-600">(${formattedDate} par ${archive.archiverUser})</span>
                            </div>
                            <div class="archive-actions">
                                <button class="px-3 py-1 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors view-archive-btn" data-sheet-name="${archive.sheetName}" data-canvas-name="${archive.canvasName}">Voir</button>
                                <button class="px-3 py-1 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors load-archive-btn" data-sheet-name="${archive.sheetName}">Charger</button>
                            </div>
                        `;
                        archivesList.appendChild(li);
                    });

                    // Ajouter les écouteurs d'événements aux boutons "Voir" et "Charger"
                    archivesList.querySelectorAll('.view-archive-btn').forEach(button => {
                        button.addEventListener('click', async (event) => {
                            const sheetName = event.target.dataset.sheetName;
                            const canvasName = event.target.dataset.canvasName;
                            await viewArchivedCanvas(sheetName, canvasName);
                        });
                    });
                    archivesList.querySelectorAll('.load-archive-btn').forEach(button => {
                        button.addEventListener('click', async (event) => {
                            const sheetName = event.target.dataset.sheetName;
                            await loadArchivedCanvasIntoMain(sheetName);
                            listArchivesModal.classList.remove('show'); // Fermer la modale après chargement
                        });
                    });
                }
            } catch (error) {
                console.error('Erreur lors de la récupération des archives :', error);
                archivesList.innerHTML = `<li class="text-red-500">Erreur de chargement des archives: ${error.message}</li>`;
                showMessage('Erreur lors du chargement des archives.', 'error');
            }
        }

        async function viewArchivedCanvas(sheetName, canvasName) {
            showMessage(`Chargement de l'archive "${canvasName}" pour visualisation...`, 'info');
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=getArchivedCanvasData&sheetName=${sheetName}`;
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Erreur réseau lors de la récupération des données d'archive: ${response.status} ${response.statusText}`);
                }
                const pixels = await response.json();
                showViewArchiveModal(canvasName, pixels);
                listArchivesModal.classList.remove('show'); // Fermer la liste des archives
            } catch (error) {
                console.error('Erreur lors de la visualisation de l\'archive :', error);
                showMessage(`Erreur lors de la visualisation de l'archive: ${error.message}`, 'error');
            }
        }

        function renderArchivedGrid(pixels) {
            archivedPixelGrid.innerHTML = ''; // Vider la grille précédente
            const pixelSize = 8; // Taille fixe pour les pixels dans l'aperçu de l'archive

            archivedPixelGrid.style.width = `${pixelSize * gridSize}px`;
            archivedPixelGrid.style.height = `${pixelSize * totalGridHeightPixels}px`;
            archivedPixelGrid.style.gridTemplateColumns = `repeat(${gridSize}, ${pixelSize}px)`;
            archivedPixelGrid.style.gridTemplateRows = `repeat(${totalGridHeightPixels}, ${pixelSize}px)`;

            // Créer une carte pour un accès rapide aux pixels par coordonnées
            const pixelMap = new Map();
            pixels.forEach(p => {
                pixelMap.set(`${p.x},${p.y}`, p);
            });

            for (let y = 0; y < totalGridHeightPixels; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const pixel = document.createElement('div');
                    pixel.classList.add('archived-pixel');
                    
                    const pixelData = pixelMap.get(`${x},${y}`);
                    const color = pixelData ? pixelData.color : '#ffffff'; // Blanc par default
                    const user = pixelData ? pixelData.user : 'Vide';

                    pixel.style.backgroundColor = color;
                    
                    const tooltip = document.createElement('span');
                    tooltip.classList.add('tooltip');
                    tooltip.textContent = user;
                    pixel.appendChild(tooltip);

                    archivedPixelGrid.appendChild(pixel);
                }
            }
        }

        async function loadArchivedCanvasIntoMain(sheetName) {
            showMessage(`Chargement de l'archive "${sheetName}" dans la toile principale...`, 'info');
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=loadArchivedCanvas`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sheetName: sheetName })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Erreur réseau lors du chargement de l'archive: ${response.status} ${response.statusText} - ${errorText}`);
                }
                const result = await response.json();
                if (result.success) {
                    showMessage(result.message, 'success');
                    loadAllPixels(); // Recharger la grille principale avec les nouvelles données
                } else {
                    showMessage(result.message || 'Erreur lors du chargement de l\'archive.', 'error');
                }
            } catch (error) {
                console.error('Erreur lors du chargement de l\'archive :', error);
                showMessage(`Erreur lors du chargement de l'archive: ${error.message}`, 'error');
            }
        }


        // Fonction pour remplir la grille (pour les tests)
        fillGridBtn.addEventListener('click', async () => {
            showMessage('Remplissage de la grille en cours...', 'info');
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=fillGrid`;
                const response = await fetch(url, { method: 'POST' }); // Utilise POST
                const result = await response.json();
                if (result.success) {
                    showMessage(result.message, 'success');
                    loadAllPixels(); // Recharger la grille après le remplissage
                } else {
                    showMessage(result.message || 'Erreur lors du remplissage de la grille.', 'error');
                }
            } catch (error) {
                console.error('Erreur lors du remplissage de la grille :', error);
                showMessage('Erreur de connexion lors du remplissage de la grille.', 'error');
            }
        });

        // Bouton pour voir les archives
        viewArchivesBtn.addEventListener('click', async () => {
            await showListArchivesModal();
        });

        // --- Timer de cooldown ---
        let cooldownInterval;
        function updateCooldownTimer(userName) {
            const lastTime = localStorage.getItem(`lastPixelTime_${userName}`);
            if (!lastTime) {
                cooldownTimerDisplay.style.display = 'none';
                return;
            }

            const lastTimestamp = parseInt(lastTime);
            const endTime = lastTimestamp + (RATE_LIMIT_SECONDS * 1000); // Temps de fin du cooldown

            clearInterval(cooldownInterval); // S'assure qu'il n'y a qu'un seul intervalle actif

            cooldownInterval = setInterval(() => {
                const now = Date.now();
                const timeLeft = Math.max(0, endTime - now); // Temps restant en ms

                if (timeLeft <= 0) {
                    cooldownTimerDisplay.style.display = 'none';
                    clearInterval(cooldownInterval);
                    showMessage('Vous pouvez placer un nouveau pixel !', 'info');
                } else {
                    const minutes = Math.floor(timeLeft / (1000 * 60));
                    const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                    cooldownTimerDisplay.textContent = `Prochain pixel : ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    cooldownTimerDisplay.style.display = 'block';
                }
            }, 1000);
        }
        
        // --- Initialisation ---
        // Générer la grille de pixels
        for (let i = 0; i < gridSize * totalGridHeightPixels; i++) {
            const pixel = document.createElement('div');
            pixel.classList.add('pixel');
            
            const x = i % gridSize;
            const y = Math.floor(i / gridSize);

            pixel.dataset.x = x;
            pixel.dataset.y = y;

            const tooltip = document.createElement('span');
            tooltip.classList.add('tooltip');
            tooltip.textContent = "Vide";
            pixel.appendChild(tooltip);

            pixel.dataset.color = "#fff";
            pixel.dataset.user = "Vide";

            pixelGrid.appendChild(pixel);

            pixel.addEventListener('click', async () => {
                // 1. Afficher la modale de sélection de couleur
                const selectedColor = await showColorModal();

                if (selectedColor === null) { // Si l'utilisateur annule la sélection de couleur
                    return;
                }
                currentColor = selectedColor; // Met à jour la couleur globale si nécessaire

                // 2. Afficher la modale de saisie du pseudo
                const userName = await showUsernameModal();

                if (userName === null) { // Si l'utilisateur annule la saisie du pseudo
                    return;
                }
                localStorage.setItem('lastPixelUser', userName); // Sauvegarder le pseudo pour le timer
                // 3. Ajouter le pixel
                addPixel(x, y, currentColor, userName);
            });
        }

        // Appeler la fonction de dimensionnement au chargement et au redimensionnement de la fenêtre
        window.addEventListener('load', () => {
            setPixelGridSize();
            centerGrid(); // Centrer la grille au chargement
            // Initialiser le timer si un pseudo est déjà connu (ex: depuis une session précédente)
            const lastUser = localStorage.getItem('lastPixelUser'); // Vous pourriez stocker le dernier pseudo utilisé
            if (lastUser) {
                    updateCooldownTimer(lastUser);
            }
        });
        window.addEventListener('resize', () => {
            setPixelGridSize();
            centerGrid(); // Centrer la grille au redimensionnement
        });

        // Charger tous les pixels au démarrage
        loadAllPixels();
        // Rafraîchir toutes les 3 secondes pour simuler le temps réel
        setInterval(loadAllPixels, 3000);
    </script>
</body>
</html>';

        const gridSize = 50; // Nombre de pixels sur un côté de la grille (50x50)
        const pixelGrid = document.getElementById('pixel-grid');
        let currentColor = 'red'; // Couleur par défaut

        // Éléments des modales
        const colorModal = document.getElementById('color-modal');
        const modalPalette = document.getElementById('modal-palette');
        const colorModalCancelBtn = document.getElementById('color-modal-cancel-btn');

        const usernameModal = document.getElementById('username-modal');
        const usernameInput = document.getElementById('username-input');
        const modalOkBtn = document.getElementById('modal-ok-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        // La modale d'archive n'est plus utilisée pour la confirmation automatique, mais pour l'archivage manuel par nom
        const archiveModal = document.getElementById('archive-modal');
        const canvasNameInput = document.getElementById('canvas-name-input');
        const archiveOkBtn = document.getElementById('archive-ok-btn');
        const archiveCancelBtn = document.getElementById('archive-cancel-btn');


        const listArchivesModal = document.getElementById('list-archives-modal');
        const archivesList = document.getElementById('archives-list');
        const listArchivesCloseBtn = document.getElementById('list-archives-close-btn');

        const viewArchiveModal = document.getElementById('view-archive-modal');
        const viewArchiveTitle = document.getElementById('view-archive-title');
        const archivedPixelGrid = document.getElementById('archived-pixel-grid');
        const viewArchiveCloseBtn = document.getElementById('view-archive-close-btn');


        const messageBox = document.getElementById('message-box');
        const cooldownTimerDisplay = document.getElementById('cooldown-timer');
        const fillGridBtn = document.getElementById('fill-grid-btn');
        const viewArchivesBtn = document.getElementById('view-archives-btn');

        let resolveColorModalPromise;
        let resolveUsernameModalPromise;
        let resolveArchiveModalPromise; // Pour l'archivage manuel par nom

        let currentZoomLevel = 1.0; // Niveau de zoom actuel
        const zoomStep = 0.1; // Pas de zoom
        const minZoom = 1.0; // Zoom minimum (la grille ne peut pas être plus petite que la taille initiale)
        const maxZoom = 5.0; // Zoom maximum

        // Variables pour le déplacement de la grille
        let isDragging = false;
        let startX, startY;
        let currentTranslateX = 0;
        let currentTranslateY = 0;

        // Définir les ratios pour le calcul de la grille
        const targetRatioWidth = 16;
        const targetRatioHeight = 9;
        // Calculer le nombre total de pixels en hauteur pour maintenir le ratio 16:9
        const totalGridHeightPixels = Math.round(gridSize * (targetRatioHeight / targetRatioWidth));
        const totalPixelsInGrid = gridSize * totalGridHeightPixels; // Nombre total de pixels attendus dans la grille

        const RATE_LIMIT_SECONDS = 3 * 60; // 3 minutes en secondes, doit correspondre à Code.gs

        // Fonction pour afficher un message temporaire
        function showMessage(message, type = 'success') {
            messageBox.textContent = message;
            messageBox.className = `message-box show ${type}`;
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 3000); // Le message disparaît après 3 secondes
        }

        // Fonction pour calculer et appliquer la taille des pixels et de la grille avec un ratio 16:9
        function setPixelGridSize() {
            // Utilise la largeur et la hauteur du viewport pour maximiser l'espace
            const availableWidth = document.documentElement.clientWidth;
            const availableHeight = document.documentElement.clientHeight;

            let pixelSize;

            // Calculer la taille d'un pixel en fonction de la contrainte de largeur et de hauteur
            const pixelSizeByWidth = availableWidth / gridSize;
            const pixelSizeByHeight = availableHeight / totalGridHeightPixels;

            // Choisir la plus petite taille de pixel pour s'assurer que la grille entière rentre
            pixelSize = Math.min(pixelSizeByWidth, pixelSizeByHeight);

            // Appliquer le niveau de zoom
            pixelSize *= currentZoomLevel;
            
            // Appliquer la taille à la grille
            pixelGrid.style.width = `${pixelSize * gridSize}px`;
            pixelGrid.style.height = `${pixelSize * totalGridHeightPixels}px`;

            pixelGrid.style.gridTemplateColumns = `repeat(${gridSize}, ${pixelSize}px)`;
            pixelGrid.style.gridTemplateRows = `repeat(${totalGridHeightPixels}, ${pixelSize}px)`;

            centerGrid();
        }

        // Fonction pour centrer la grille
        function centerGrid() {
            const gridRect = pixelGrid.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Calcule le décalage nécessaire pour centrer la grille
            currentTranslateX = (viewportWidth / 2) - (gridRect.width / 2);
            currentTranslateY = (viewportHeight / 2) - (gridRect.height / 2);
            
            // Applique la translation
            pixelGrid.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px)`;
        }

        // Gestion du zoom avec la molette de la souris
        pixelGrid.addEventListener('wheel', (event) => {
            event.preventDefault(); // Empêche le défilement de la page

            const oldZoomLevel = currentZoomLevel;

            if (event.deltaY < 0) { // Molette vers le haut (zoom avant)
                currentZoomLevel = Math.min(maxZoom, currentZoomLevel + zoomStep);
            } else { // Molette vers le bas (zoom arrière)
                currentZoomLevel = Math.max(minZoom, currentZoomLevel - zoomStep);
            }

            if (oldZoomLevel !== currentZoomLevel) {
                setPixelGridSize(); // Recalcule la taille de la grille avec le nouveau zoom
            }
        });

        // Gestion du déplacement de la grille (drag) avec le clic molette
        pixelGrid.addEventListener('mousedown', (event) => {
            // event.button === 1 correspond au clic du bouton central (molette)
            if (event.button === 1) {
                event.preventDefault(); // Empêche le comportement par défaut du clic molette (autoscroll)
                isDragging = true;
                startX = event.clientX - currentTranslateX;
                startY = event.clientY - currentTranslateY;
                pixelGrid.style.cursor = 'grabbing';
            }
        });

        window.addEventListener('mousemove', (event) => {
            if (!isDragging) return;
            event.preventDefault(); // Empêche la sélection de texte lors du glisser-déposer
            currentTranslateX = event.clientX - startX;
            currentTranslateY = event.clientY - startY;
            pixelGrid.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px)`;
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            pixelGrid.style.cursor = 'grab';
        });


        // --- Fonctions pour gérer les modales ---
        function showColorModal() {
            return new Promise(resolve => {
                resolveColorModalPromise = resolve;
                colorModal.classList.add('show');
            });
        }

        function showUsernameModal() {
            return new Promise(resolve => {
                resolveUsernameModalPromise = resolve;
                usernameInput.value = '';
                usernameModal.classList.add('show');
                usernameInput.focus();
            });
        }

        // Modale d'archivage manuel par nom
        function showManualArchiveModal() {
            return new Promise(resolve => {
                resolveArchiveModalPromise = resolve;
                archiveModal.classList.add('show');
                canvasNameInput.value = ''; // Réinitialiser le champ de nom
                canvasNameInput.focus();
            });
        }

        function showListArchivesModal() {
            return new Promise(async resolve => {
                listArchivesModal.classList.add('show');
                await populateArchivesList();
                resolve();
            });
        }

        function showViewArchiveModal(title, pixels) {
            viewArchiveTitle.textContent = title;
            renderArchivedGrid(pixels);
            viewArchiveModal.classList.add('show');
        }

        // Gestionnaire pour la sélection de couleur dans la modale
        modalPalette.addEventListener('click', (event) => {
            if (event.target.classList.contains('color-box')) {
                const selectedColor = event.target.dataset.color;
                colorModal.classList.remove('show');
                resolveColorModalPromise(selectedColor); // Résout la promesse avec la couleur choisie
            }
        });

        // Gestionnaire pour le bouton Annuler de la modale de couleur
        colorModalCancelBtn.addEventListener('click', () => {
            colorModal.classList.remove('show');
            resolveColorModalPromise(null); // Résout la promesse avec null si annulé
        });

        // Gestionnaire pour le bouton OK de la modale de pseudo
        modalOkBtn.addEventListener('click', () => {
            const userName = usernameInput.value.trim();
            usernameModal.classList.remove('show');
            resolveUsernameModalPromise(userName === '' ? 'Anonyme' : userName);
        });

        // Gestionnaire pour le bouton Annuler de la modale de pseudo
        modalCancelBtn.addEventListener('click', () => {
            usernameModal.classList.remove('show');
            resolveUsernameModalPromise(null);
        });

        // Gérer la touche Entrée dans l'input de la modale de pseudo
        usernameInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                modalOkBtn.click();
            }
        });

        // Gestionnaire pour le bouton Archiver de la modale d'archivage (sur Google Sheet)
        archiveOkBtn.addEventListener('click', async () => {
            const canvasName = canvasNameInput.value.trim();
            if (!canvasName) {
                showMessage('Veuillez donner un nom à la toile.', 'error');
                return;
            }
            archiveModal.classList.remove('show');
            resolveArchiveModalPromise(canvasName); // Résout la promesse avec le nom
        });

        // Gestionnaire pour le bouton Annuler de la modale d'archivage
        archiveCancelBtn.addEventListener('click', () => {
            archiveModal.classList.remove('show');
            resolveArchiveModalPromise(null); // Résout la promesse avec null si annulé
        });

        // Gérer la touche Entrée dans l'input de la modale de nom de toile
        canvasNameInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                archiveOkBtn.click();
            }
        });

        // Fermer la modale de liste d'archives
        listArchivesCloseBtn.addEventListener('click', () => {
            listArchivesModal.classList.remove('show');
        });

        // Fermer la modale de visualisation d'archive
        viewArchiveCloseBtn.addEventListener('click', () => {
            viewArchiveModal.classList.remove('show');
        });


        // --- Fonctions de logique métier ---
        function updatePixelOnGrid(x, y, color, user) {
            const pixelElement = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (pixelElement) {
                pixelElement.style.backgroundColor = color;
                pixelElement.dataset.color = color;
                pixelElement.dataset.user = user;
                pixelElement.querySelector('.tooltip').textContent = user;
                pixelElement.classList.add('placed');
            }
        }

        async function addPixel(x, y, color, userName) {
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=addPixel&x=${x}&y=${y}&color=${color}&user=${userName}`;
                const response = await fetch(url, {
                    method: 'GET',
                });
                const result = await response.json(); // La réponse inclura { success: true/false, message, pixel }

                if (result.success) {
                    updatePixelOnGrid(result.pixel.x, result.pixel.y, result.pixel.color, result.pixel.user);
                    localStorage.setItem(`lastPixelTime_${userName}`, Date.now()); // Enregistre le timestamp localement
                    updateCooldownTimer(userName); // Met à jour le timer immédiatement
                    showMessage('Pixel placé avec succès !', 'success');
                } else {
                    showMessage(result.message || 'Erreur lors du placement du pixel.', 'error');
                }
            } catch (error) {
                console.error('Erreur lors de l\'ajout du pixel :', error);
                showMessage('Erreur de connexion au serveur.', 'error');
            }
        }

        async function loadAllPixels() {
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=getPixels`;
                const response = await fetch(url);
                const pixels = await response.json();
                
                // Réinitialiser la grille visuellement avant de la remplir
                document.querySelectorAll('.pixel').forEach(pixel => {
                    pixel.style.backgroundColor = '#fff';
                    pixel.dataset.color = '#fff';
                    pixel.dataset.user = 'Vide';
                    pixel.querySelector('.tooltip').textContent = 'Vide';
                    pixel.classList.remove('placed');
                });

                pixels.forEach(p => {
                    updatePixelOnGrid(p.x, p.y, p.color, p.user);
                });

                // Après le chargement, vérifier si la grille est pleine
                const countUrl = `${APPS_SCRIPT_API_URL}?action=countPixels`;
                const countResponse = await fetch(countUrl);
                const countResult = await countResponse.json();

                if (countResult.count >= totalPixelsInGrid) {
                    // Afficher la modale d'archivage manuel (si ce n'est pas déjà affiché)
                    if (!archiveModal.classList.contains('show')) {
                        const archiverUser = usernameInput.value.trim() || 'Anonyme'; // Utilise le pseudo actuel ou "Anonyme"
                        const canvasName = await showManualArchiveModal(); // Demande le nom de la toile
                        if (canvasName) {
                            showMessage(`Grille pleine ! Archivage de "${canvasName}" en cours...`, 'info');
                            await archiveCurrentGridToSheet(canvasName, archiverUser);
                        } else {
                            showMessage('Archivage annulé.', 'info');
                        }
                    }
                }

            } catch (error) {
                console.error('Erreur lors du chargement des pixels :', error);
                showMessage('Erreur lors du chargement des pixels.', 'error');
            }
        }

        async function archiveCurrentGridToSheet(canvasName, archiverUser) {
            showMessage(`Archivage de "${canvasName}" en cours...`, 'info');
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=archiveGridToSheet`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ canvasName: canvasName, archiverUser: archiverUser })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Erreur réseau lors de l'archivage sur feuille: ${response.status} ${response.statusText} - ${errorText}`);
                }

                const result = await response.json();
                if (result.success) {
                    showMessage(result.message, 'success');
                    loadAllPixels(); // Recharger la grille principale après archivage et effacement
                } else {
                    showMessage(result.message || 'Erreur lors de l\'archivage sur Google Sheet.', 'error');
                }
            } catch (error) {
                console.error('Erreur lors de l\'archivage sur Google Sheet :', error);
                showMessage('Erreur de connexion lors de l\'archivage sur Google Sheet.', 'error');
            }
        }

        async function populateArchivesList() {
            archivesList.innerHTML = '<li class="text-gray-500">Chargement des archives...</li>';
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=getArchivedCanvases`;
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Erreur réseau lors de la récupération des archives: ${response.status} ${response.statusText}`);
                }
                const archives = await response.json();

                archivesList.innerHTML = ''; // Vider la liste
                if (archives.length === 0) {
                    archivesList.innerHTML = '<li class="text-gray-500">Aucune archive trouvée.</li>';
                } else {
                    archives.forEach(archive => {
                        const li = document.createElement('li');
                        const formattedDate = new Date(archive.timestamp).toLocaleString();
                        li.innerHTML = `
                            <div class="archive-info">
                                <strong class="text-gray-900">${archive.canvasName}</strong>
                                <span class="text-gray-600">(${formattedDate} par ${archive.archiverUser})</span>
                            </div>
                            <div class="archive-actions">
                                <button class="px-3 py-1 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors view-archive-btn" data-sheet-name="${archive.sheetName}" data-canvas-name="${archive.canvasName}">Voir</button>
                                <button class="px-3 py-1 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors load-archive-btn" data-sheet-name="${archive.sheetName}">Charger</button>
                            </div>
                        `;
                        archivesList.appendChild(li);
                    });

                    // Ajouter les écouteurs d'événements aux boutons "Voir" et "Charger"
                    archivesList.querySelectorAll('.view-archive-btn').forEach(button => {
                        button.addEventListener('click', async (event) => {
                            const sheetName = event.target.dataset.sheetName;
                            const canvasName = event.target.dataset.canvasName;
                            await viewArchivedCanvas(sheetName, canvasName);
                        });
                    });
                    archivesList.querySelectorAll('.load-archive-btn').forEach(button => {
                        button.addEventListener('click', async (event) => {
                            const sheetName = event.target.dataset.sheetName;
                            await loadArchivedCanvasIntoMain(sheetName);
                            listArchivesModal.classList.remove('show'); // Fermer la modale après chargement
                        });
                    });
                }
            } catch (error) {
                console.error('Erreur lors de la récupération des archives :', error);
                archivesList.innerHTML = `<li class="text-red-500">Erreur de chargement des archives: ${error.message}</li>`;
                showMessage('Erreur lors du chargement des archives.', 'error');
            }
        }

        async function viewArchivedCanvas(sheetName, canvasName) {
            showMessage(`Chargement de l'archive "${canvasName}" pour visualisation...`, 'info');
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=getArchivedCanvasData&sheetName=${sheetName}`;
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Erreur réseau lors de la récupération des données d'archive: ${response.status} ${response.statusText}`);
                }
                const pixels = await response.json();
                showViewArchiveModal(canvasName, pixels);
                listArchivesModal.classList.remove('show'); // Fermer la liste des archives
            } catch (error) {
                console.error('Erreur lors de la visualisation de l\'archive :', error);
                showMessage(`Erreur lors de la visualisation de l'archive: ${error.message}`, 'error');
            }
        }

        function renderArchivedGrid(pixels) {
            archivedPixelGrid.innerHTML = ''; // Vider la grille précédente
            const pixelSize = 8; // Taille fixe pour les pixels dans l'aperçu de l'archive

            archivedPixelGrid.style.width = `${pixelSize * gridSize}px`;
            archivedPixelGrid.style.height = `${pixelSize * totalGridHeightPixels}px`;
            archivedPixelGrid.style.gridTemplateColumns = `repeat(${gridSize}, ${pixelSize}px)`;
            archivedPixelGrid.style.gridTemplateRows = `repeat(${totalGridHeightPixels}, ${pixelSize}px)`;

            // Créer une carte pour un accès rapide aux pixels par coordonnées
            const pixelMap = new Map();
            pixels.forEach(p => {
                pixelMap.set(`${p.x},${p.y}`, p);
            });

            for (let y = 0; y < totalGridHeightPixels; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const pixel = document.createElement('div');
                    pixel.classList.add('archived-pixel');
                    
                    const pixelData = pixelMap.get(`${x},${y}`);
                    const color = pixelData ? pixelData.color : '#ffffff'; // Blanc par default
                    const user = pixelData ? pixelData.user : 'Vide';

                    pixel.style.backgroundColor = color;
                    
                    const tooltip = document.createElement('span');
                    tooltip.classList.add('tooltip');
                    tooltip.textContent = user;
                    pixel.appendChild(tooltip);

                    archivedPixelGrid.appendChild(pixel);
                }
            }
        }

        async function loadArchivedCanvasIntoMain(sheetName) {
            showMessage(`Chargement de l'archive "${sheetName}" dans la toile principale...`, 'info');
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=loadArchivedCanvas`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sheetName: sheetName })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Erreur réseau lors du chargement de l'archive: ${response.status} ${response.statusText} - ${errorText}`);
                }
                const result = await response.json();
                if (result.success) {
                    showMessage(result.message, 'success');
                    loadAllPixels(); // Recharger la grille principale avec les nouvelles données
                } else {
                    showMessage(result.message || 'Erreur lors du chargement de l\'archive.', 'error');
                }
            } catch (error) {
                console.error('Erreur lors du chargement de l\'archive :', error);
                showMessage(`Erreur lors du chargement de l'archive: ${error.message}`, 'error');
            }
        }


        // Fonction pour remplir la grille (pour les tests)
        fillGridBtn.addEventListener('click', async () => {
            showMessage('Remplissage de la grille en cours...', 'info');
            try {
                const url = `${APPS_SCRIPT_API_URL}?action=fillGrid`;
                const response = await fetch(url, { method: 'POST' }); // Utilise POST
                const result = await response.json();
                if (result.success) {
                    showMessage(result.message, 'success');
                    loadAllPixels(); // Recharger la grille après le remplissage
                } else {
                    showMessage(result.message || 'Erreur lors du remplissage de la grille.', 'error');
                }
            } catch (error) {
                console.error('Erreur lors du remplissage de la grille :', error);
                showMessage('Erreur de connexion lors du remplissage de la grille.', 'error');
            }
        });

        // Bouton pour voir les archives
        viewArchivesBtn.addEventListener('click', async () => {
            await showListArchivesModal();
        });

        // --- Timer de cooldown ---
        let cooldownInterval;
        function updateCooldownTimer(userName) {
            const lastTime = localStorage.getItem(`lastPixelTime_${userName}`);
            if (!lastTime) {
                cooldownTimerDisplay.style.display = 'none';
                return;
            }

            const lastTimestamp = parseInt(lastTime);
            const endTime = lastTimestamp + (RATE_LIMIT_SECONDS * 1000); // Temps de fin du cooldown

            clearInterval(cooldownInterval); // S'assure qu'il n'y a qu'un seul intervalle actif

            cooldownInterval = setInterval(() => {
                const now = Date.now();
                const timeLeft = Math.max(0, endTime - now); // Temps restant en ms

                if (timeLeft <= 0) {
                    cooldownTimerDisplay.style.display = 'none';
                    clearInterval(cooldownInterval);
                    showMessage('Vous pouvez placer un nouveau pixel !', 'info');
                } else {
                    const minutes = Math.floor(timeLeft / (1000 * 60));
                    const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                    cooldownTimerDisplay.textContent = `Prochain pixel : ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    cooldownTimerDisplay.style.display = 'block';
                }
            }, 1000);
        }
        
        // --- Initialisation ---
        // Générer la grille de pixels
        for (let i = 0; i < gridSize * totalGridHeightPixels; i++) {
            const pixel = document.createElement('div');
            pixel.classList.add('pixel');
            
            const x = i % gridSize;
            const y = Math.floor(i / gridSize);

            pixel.dataset.x = x;
            pixel.dataset.y = y;

            const tooltip = document.createElement('span');
            tooltip.classList.add('tooltip');
            tooltip.textContent = "Vide";
            pixel.appendChild(tooltip);

            pixel.dataset.color = "#fff";
            pixel.dataset.user = "Vide";

            pixelGrid.appendChild(pixel);

            pixel.addEventListener('click', async () => {
                // 1. Afficher la modale de sélection de couleur
                const selectedColor = await showColorModal();

                if (selectedColor === null) { // Si l'utilisateur annule la sélection de couleur
                    return;
                }
                currentColor = selectedColor; // Met à jour la couleur globale si nécessaire

                // 2. Afficher la modale de saisie du pseudo
                const userName = await showUsernameModal();

                if (userName === null) { // Si l'utilisateur annule la saisie du pseudo
                    return;
                }
                localStorage.setItem('lastPixelUser', userName); // Sauvegarder le pseudo pour le timer
                // 3. Ajouter le pixel
                addPixel(x, y, currentColor, userName);
            });
        }

        // Appeler la fonction de dimensionnement au chargement et au redimensionnement de la fenêtre
        window.addEventListener('load', () => {
            setPixelGridSize();
            centerGrid(); // Centrer la grille au chargement
            // Initialiser le timer si un pseudo est déjà connu (ex: depuis une session précédente)
            const lastUser = localStorage.getItem('lastPixelUser'); // Vous pourriez stocker le dernier pseudo utilisé
            if (lastUser) {
                    updateCooldownTimer(lastUser);
            }
        });
        window.addEventListener('resize', () => {
            setPixelGridSize();
            centerGrid(); // Centrer la grille au redimensionnement
        });

        // Charger tous les pixels au démarrage
        loadAllPixels();
        // Rafraîchir toutes les 3 secondes pour simuler le temps réel
        setInterval(loadAllPixels, 3000);
    </script>
</body>
</html>
